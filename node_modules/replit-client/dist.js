"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

/* @flow */

var Promise = require("bluebird");
var EventEmitter = require("events").EventEmitter;

var RETRIES = 7;
var DELAY = 500;
var LANG_EXTS = {
  python: "py",
  ruby: "rb",
  php: "php",
  python3: "py",
  nodejs: "js",
  go: "go",
  java: "java",
  cpp: "cpp",
  cpp11: "cpp",
  c: "c",
  csharp: "cs",
  fsharp: "fs",
  rust: "rs",
  swift: "swift" };

/*:: type stdout = (output: string) => any*/
/*:: type msg = {data: ?string; error: ?string; command: string; }*/
/*:: type file = {content: string; name: string }*/

var ReplitClient = (function (EventEmitter) {
  /*:: _host: string; */
  /*:: _port: string; */
  /*:: _language: string; */
  /*:: _authToken: string; */
  /*:: _authFailed: boolean; */
  /*:: _retries: number; */
  /*:: _ws: any; */
  /*:: _stdout: ?stdout; */
  /*:: _msgQueue: Array<msg>; */
  /*:: _msgResolvers: Array<function>; */
  /*:: _connecting: ?Promise; */
  /*:: _evalConnecting: ?Promise; */
  /*:: _pingTimer: number; */
  /*:: _socketCreator: ?function; */
  /*:: _timeout: number; */
  /*:: _handshakeRetries: number; */

  function ReplitClient(host, /*: string*/port, /*: string*/language, /*: string*/authToken, /*: { msg_mac: string; time_created: number; }*/socketCreator, /*: function*/options /*: { timeout: number; }*/
  ) {
    _get(Object.getPrototypeOf(ReplitClient.prototype), "constructor", this).call(this);
    this._host = host;
    this._port = port;
    this._language = language;
    this._authToken = authToken.time_created + ":" + authToken.msg_mac;
    this._init();
    this._retries = RETRIES;
    this._handshakeRetries = RETRIES;
    this._socketCreator = socketCreator;
    if (options != null) {
      this._timeout = options.timeout;
    }
  }

  _inherits(ReplitClient, EventEmitter);

  _prototypeProperties(ReplitClient, null, {
    connect: {
      value: function connect() /*: Promise<ReplitClient>*/{
        if (this._connecting) {
          return this._connecting;
        }

        this._connecting = this._connect();
        return this._connecting;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    disconnect: {
      value: function disconnect() /*: Promise<bool>*/{
        var _this = this;
        if (!(this._ws && this._ws.readyState === this._ws.OPEN)) {
          return Promise.resolve(true);
        }

        clearTimeout(this._pingTimer);
        return new Promise(function (resolve) {
          _this._ws.onclose = function () {
            return resolve(true);
          };
          _this._ws.close();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    write: {
      value: function write(str /*: string*/) {
        var _this2 = this;
        if (!this._evalConnecting) {
          return Promise.reject(new Error("Must evaluate before writing"));
        }
        return this._evalConnecting.then(function () {
          _this2._sendMessage("input", str);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluate: {
      value: function evaluate(code, /*: string*/_ref) /*: Promise<{
                                                        error: ?string;
                                                        data: ?string;
                                                        }>*/
      {
        var _this3 = this;
        var stdout = _ref.stdout;
        this._evalConnecting = this._connectOrTry();
        return this._evalConnecting.then(function () {
          _this3._stdout = stdout;
          _this3._sendMessage("eval", code);
          return _this3._waitForResult();
        }).then(function (result) {
          _this3._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluateOnce: {
      value: function evaluateOnce(code, /*: string*/options /*: ?{
                                                             stdout: ?stdout,
                                                             timeout: ?{
                                                             time: number,
                                                             callback: () => bool
                                                             }
                                                             }*/
      ) /*: Promise<{
         error: ?string;
         data: ?string;
         }>*/
      {
        var _this4 = this;
        return new Promise(function (resolve, reject) {
          var req = new XMLHttpRequest();

          var t = null;
          if (options != null && options.timeout) {
            var callback;
            (function () {
              var timeout = options.timeout;
              callback = function () {
                // this is just to make flow happy
                var stop = timeout.callback();
                if (stop) {
                  req.abort();
                  reject(new Error("Aborted"));
                } else {
                  t = setTimeout(callback, timeout.time);
                }
              };

              t = setTimeout(callback, timeout.time);
            })();
          }

          req.onload = function () {
            if (req.status !== 200) {
              clearTimeout(t);
              reject(new Error(req.responseText));
            } else {
              var data /*: Array<msg>*/ = [];
              try {
                data = JSON.parse(req.responseText);
              } catch (e) {
                clearTimeout(t);
                reject(new Error("Error parsing response"));
                return;
              }
              data.forEach(function (msg) {
                if (msg.command === "output") {
                  if (options && options.stdout != null) {
                    options.stdout(msg.data);
                  }
                } else if (msg.command === "result") {
                  clearTimeout(t);
                  resolve(msg);
                }
              });
            }
          };

          var protocol = "http";
          var port = _this4._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "https";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          req.open("POST", protocol + "://" + _this4._host + ":" + port + "/eval", true);

          req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; param=value");

          var data = "";
          data += "auth=" + encodeURIComponent(_this4._authToken);
          data += "&language=" + encodeURIComponent(_this4._language);
          data += "&code=" + encodeURIComponent(code);

          req.send(data);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitUntilReady: {
      value: function WaitUntilReady() {
        var _this5 = this;
        return this._nextMessage().then(function (msg) {
          if (msg.command === "ready") {
            return msg;
          }

          return _this5._waitUntilReady();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stop: {
      value: function stop() /*: Promise*/{
        return this._reset("stop");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    reset: {
      value: function reset() /*: Promise*/{
        return this._reset("reset");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _reset: {
      value: function Reset(message /*: string*/) /*: Promise*/{
        var _this6 = this;
        return this._connectOrTry().then(function () {
          var resolver;
          while (resolver = _this6._msgResolvers.shift()) {
            resolver({ command: "skip" });
          }
          _this6._sendMessage(message);
          return _this6._waitUntilReady();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            throw new Error("Expected ready after reset");
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runProject: {
      value: function runProject(files, /*: Array<file>*/_ref2) /*: Promise<{
                                                                   error: ?string;
                                                                   data: ?string;
                                                                   }>*/
      {
        var _this7 = this;
        var stdout = _ref2.stdout;
        this._evalConnecting = this.reset();
        return this._evalConnecting.then(function () {
          _this7._stdout = stdout;
          // Need to stringify files because 'data' field is expected
          // to be string and not array.
          _this7._sendMessage("runProject", JSON.stringify(files));
          return _this7._waitForResult();
        }).then(function (result) {
          _this7._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runUnitTests: {
      value: function runUnitTests(_ref3) /*:
                                          Promise<{
                                          error: ?string;
                                          passed: bool;
                                          failures: Array<{ name: string; stack: string; }>;
                                          }>
                                          */{
        var _this8 = this;
        var files = _ref3.files;
        var suiteCode = _ref3.suiteCode;
        this._evalConnecting = this.reset();
        return this._evalConnecting.then(function () {
          // Need to stringify files because 'data' field is expected
          // to be string and not array.
          _this8._sendMessage("runUnitTests", JSON.stringify({
            files: files,
            suiteCode: suiteCode }));
          return _this8._waitForResult();
        }).then(function (result) {
          _this8._evalConnecting = null;
          var data;
          if (result.data) {
            data = JSON.parse(result.data);
          } else {
            data = { passed: false, failures: [] };
          }
          return {
            passed: data.passed,
            failures: data.failures,
            error: result.error };
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runSingleUnitTests: {
      value: function runSingleUnitTests(_ref4) {
        var code = _ref4.code;
        var suiteCode = _ref4.suiteCode;
        var files = [{
          name: (this._language === "java" ? "Main" : "main") + "." + LANG_EXTS[this._language],
          content: code }];

        return this.runUnitTests({
          files: files,
          suiteCode: suiteCode });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _init: {
      value: function Init() {
        this._ws = null;
        this._stdout = null;

        this._msgQueue = [];
        this._msgResolvers = [];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _nextMessage: {
      value: function NextMessage() /*: Promise*/{
        var _this9 = this;
        return new Promise(function (resolve) {
          if (_this9._msgQueue.length) {
            resolve(_this9._msgQueue.shift());
          } else {
            _this9._msgResolvers.push(resolve);
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connectOrTry: {

      // This will make sure we at least try to connect
      // and not get stuck in some past error.
      // use case is what if we were disconnected from the internet
      // and now we are connected.
      value: function ConnectOrTry() /*: Promise<ReplitClient> */{
        var _this10 = this;
        return this.connect()["catch"](function () {
          _this10._connecting = null;
          return _this10.connect();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handshakeRetry: {
      value: function HandshakeRetry(resolve, /*: function */reject /*: function */) {
        this._init();
        this._handshakeRetries -= 1;

        if (this._handshakeRetries < 1) {
          return reject(new HandshakeError("Handshake error"));
        }

        this._connect().then(resolve, reject);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connect: {
      value: function Connect() /*: Promise<ReplitClient>*/{
        var _this11 = this;
        return new Promise(function (resolve, reject) {
          _this11.emit("connecting");

          var protocol = "ws";
          var port = _this11._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "wss";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          var url = protocol + "://" + _this11._host + ":" + port + "/ws";
          _this11._ws = _this11._socketCreator ? _this11._socketCreator(url) : new WebSocket(url);

          var timedout = false;
          var timer;
          if (_this11._timeout) {
            timer = setTimeout(function () {
              timedout = true;
              var err = new TimeoutError("Timed out on connecting");
              reject(err);
              _this11.disconnect();
            }, _this11._timeout);
          }

          _this11._ws.onopen = function () {
            _this11._ws.onclose = _this11._handshakeRetry.bind(_this11, resolve, reject);

            // TODO: if we disconnect in a handshake (e.g. faulty server) we should
            // have retry logic.
            _this11._handshake().then(function () {
              if (timedout) {
                _this11.disconnect();
                return;
              }

              _this11._ws.onclose = _this11._closeHandler.bind(_this11);
              clearTimeout(timer);
              // Reset retries.
              _this11._retries = RETRIES;
              resolve(_this11);
              _this11.emit("connected");
            }, function (err) {
              reject(err);
              _this11._ws.onclose = null;
              _this11.disconnect();
            });
          };
          _this11._ws.onclose = function (e) {
            if (timedout) {
              return;
            }

            reject(new Error(errMsgFromCloseEvent(e)));
          }, _this11._ws.onmessage = _this11._messageHandler.bind(_this11);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handshake: {
      value: function Handshake() /*: Promise */{
        var _this12 = this;
        var msg;

        this._sendMessage("auth", this._authToken);
        return this._nextMessage().then(function (msg) {
          if (msg.command !== "auth_result") {
            throw new Error("Expected \"auth_result\" command: " + msg.command);
          }
          if (msg.data !== "true") {
            _this12._authFailed = true;
            throw new Error("Failed to auth");
          }
          _this12._sendMessage("select_language", _this12._language);
          return _this12._nextMessage();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            _this12._authFailed = true;
            if (msg.command === "error") {
              throw new Error(msg.data);
            }
            throw new Error("Expected \"ready\" command but got: " + msg.command);
          }

          _this12._ping();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _sendMessage: {
      value: function SendMessage(command /*: string*/) {
        var data /*: string*/ = arguments[1] === undefined ? "" : arguments[1];
        var msg = { command: command, data: data };
        this._ws.send(JSON.stringify(msg));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _messageHandler: {
      value: function MessageHandler(e /*: {data: string} */) {
        var msg = JSON.parse(e.data);

        if (msg.command === "pong") {
          this._ping();
          return;
        } else if (msg.command === "ping") {
          this._pong();
          return;
        } else if (msg.command === "output") {
          if (this._stdout != null) {
            this._stdout(msg.data);
          }
          return;
        }

        if (this._msgResolvers.length) {
          var resolver = this._msgResolvers.shift();
          resolver(msg);
        } else {
          this._msgQueue.push(msg);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitForResult: {
      value: function WaitForResult() /*: Promise*/{
        var _this13 = this;
        return this._nextMessage().then(function (msg) {
          switch (msg.command) {
            case "result":
              return msg;
            case "input":
              return _this13._waitForResult();
            case "skip":
              return { command: "result", data: "" };
              // output is handled by the message handler since it can happen
              // outside the eval loop (e.g. nodejs settimeout)
          }
          throw new Error("Unexpected command: " + msg.command);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _closeHandler: {
      value: function CloseHandler(e /*: CloseEvent | TimeoutError */) {
        var _this14 = this;
        this._init();
        this._retries -= 1;
        clearTimeout(this._pingTimer);

        if (this._authFailed) {
          this._retries = 0;
        }

        if (this._retries < 1) {
          this.emit("disconnected", { retry: false });
          this._connecting = null;
          this._retries = 0;
          return Promise.reject(e);
        } else {
          var delay = (RETRIES - this._retries) * DELAY;
          this.emit("disconnected", { retry: true, delay: delay });
          this._connecting = new Promise(function (resolve, reject) {
            setTimeout(function () {
              return _this14._connect().then(resolve, reject);
            }, delay);
          });
          return this._connecting["catch"](function (e) {
            return _this14._closeHandler(e);
          });
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _ping: {
      value: function Ping() {
        var _this15 = this;
        this._pingTimer = setTimeout(function () {
          _this15._ws.send(JSON.stringify({ command: "ping" }));
        }, 10 * 1000);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _pong: {
      value: function Pong() {
        this._ws.send(JSON.stringify({ command: "pong" }));
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ReplitClient;
})(EventEmitter);

function errMsgFromCloseEvent(e) {
  var msg = e.reason || e.type || "";
  if (e.code) {
    msg += ": " + e.code;
  }
  return msg;
}

function TimeoutError(msg) {
  Error.call(this);
  if (Error.capturStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = "TimeoutError";
  this.msg = msg;
}

function HandshakeError(msg) {
  Error.call(this);
  if (Error.capturStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = "HandshakeError";
  this.msg = msg;
}

module.exports = ReplitClient;
/*: { stdout: ?stdout }*/
/*: { stdout: ?stdout }*/
/*: {
files: Array<file>,
suiteCode: string,
} */ /*: {
     code: string,
     suiteCode: string,
     }*/

